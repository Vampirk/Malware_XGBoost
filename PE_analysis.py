import os
import pefile
import pandas as pd
import hashlib
import math
from collections import Counter
import logging
import argparse
import configparser
import multiprocessing

# 명령행 인자 파싱
parser = argparse.ArgumentParser(description='PE File Analyzer')
parser.add_argument('--config', default='config.ini', help='Configuration file path')
args = parser.parse_args()

# 설정 파일 읽기
config = configparser.ConfigParser()
config.read(args.config)

folder_path_malware = config.get('Paths', 'malware_folder')
folder_path_normal = config.get('Paths', 'normal_folder')

# 로거 설정
logging.basicConfig(filename='pe_analyzer.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# 전역 변수를 상수로 선언
HASH_ALGORITHMS = ['md5', 'sha1', 'sha256']

# 의심스러운 키워드 리스트
suspicious_keywords = {
    'file': ['CreateFile', 'WriteFile', 'ReadFile', 'DeleteFile', 'MoveFile', 'CopyFile'],
    'process': ['CreateProcess', 'OpenProcess', 'TerminateProcess'],
    'service': ['OpenService', 'CreateService', 'StartService', 'ControlService'],
    'socket': ['socket', 'bind', 'connect', 'send', 'recv', 'listen'],
    'http': ['HttpOpenRequest', 'HttpSendRequest', 'InternetOpen', 'InternetOpenUrl'],
    'encryption': ['CryptEncrypt', 'CryptDecrypt', 'CryptHashData'],
    'compression': ['Compress', 'Decompress', 'Zlib', 'LZ77'],
    'registry': ['RegOpenKey', 'RegCreateKey', 'RegDeleteKey', 'RegQueryValue', 'RegSetValue'],
    'system_info': ['GetSystemInfo', 'GetNativeSystemInfo', 'GetComputerName', 'GetUserName', 'GetWindowsDirectory'],
    'shellcode': ['VirtualAlloc', 'VirtualProtect', 'CreateThread', 'ShellExecute', 'GetProcAddress'],
    'anti_analysis': ['IsDebuggerPresent', 'OutputDebugString', 'CheckRemoteDebuggerPresent', 'VirtualQuery', 'CreateThread'],
}

# Flatten the suspicious_keywords dictionary
suspicious_keywords_flat = [keyword for sublist in suspicious_keywords.values() for keyword in sublist]

# API 호출 분석 함수
def analyze_api_frequency(pe):
    try:
        api_calls = []
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                api_calls.extend(func.name.decode('utf-8') for func in entry.imports)

        return Counter(api_calls)
    except Exception as e:
        logging.error(f"An error occurred while analyzing API frequency: {e}")
        return {}

# IAT 분석 함수
def analyze_iat(pe):
    try:
        iat_entries = []
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8')
                iat_entries.extend({'DLL': dll_name, 'Function': func.name.decode('utf-8')} for func in entry.imports)

        return iat_entries
    except Exception as e:
        logging.error(f"An error occurred while analyzing IAT: {e}")
        return []

# 엔트로피 계산 함수
def calculate_entropy(data):
    if not data:
        return 0
    counter = Counter(data)
    entropy = -sum((count / len(data)) * math.log2(count / len(data)) for count in counter.values())
    return entropy

# 파일 해시 계산 함수
def calculate_file_hash(file_path):
    hashes = {}
    with open(file_path, 'rb') as file:
        contents = file.read()
        for algorithm in HASH_ALGORITHMS:
            hasher = hashlib.new(algorithm)
            hasher.update(contents)
            hashes[algorithm] = hasher.hexdigest()
    return hashes

def is_packed(pe):
    try:
        nop_sequence_count = 0
        suspicious_sections = 0
        high_entropy_sections = 0

        # NOP 명령어 시퀀스 확인
        for section in pe.sections:
            if b'\x90' * 10 in section.get_data():
                nop_sequence_count += 1

        # 섹션 특성 검사
        for section in pe.sections:
            characteristics = section.Characteristics

            # 섹션이 쓰기 가능하고 실행 가능인지 확인하지만, DLL의 정상적인 특성도 고려
            if characteristics & 0x60000020 == 0x60000020 and section.SizeOfRawData > 512:
                suspicious_sections += 1

            # 섹션 크기가 너무 작은지 확인하지만, 크기만으로 판단하지 않음
            if section.SizeOfRawData < 10:
                suspicious_sections += 1

        # 엔트로피 검사
        for section in pe.sections:
            if calculate_entropy(section.get_data()) > 7.0:
                high_entropy_sections += 1

        # 헤더 이상 검사
        header_anomalies = pe.FILE_HEADER.SizeOfOptionalHeader != 0xE0 or \
                           pe.OPTIONAL_HEADER.DllCharacteristics & 0x40 != 0

        if nop_sequence_count > 2 or suspicious_sections > 2 or high_entropy_sections > 2 or header_anomalies:
            return True

        return False
    except Exception as e:
        logging.error(f"An error occurred while checking for packing: {e}")
        return False

# 암호화 섹션 여부 확인 함수
def contains_encrypted_section(pe):
    for section in pe.sections:
        if calculate_entropy(section.get_data()) > 7.0:
            return True
    return False

# 의심스러운 문자열 검출 함수
def detect_suspicious_strings(pe):
    try:
        detected_strings = []
        for section in pe.sections:
            section_data = section.get_data().decode(errors='ignore')
            detected_strings.extend(keyword for keyword in suspicious_keywords_flat if keyword.lower() in section_data.lower())

        return list(set(detected_strings))
    except Exception as e:
        logging.error(f"An error occurred while detecting suspicious strings: {e}")
        return []

# PE 파일 분석 함수
def analyze_pe(file_path, is_malware_folder):
    try:
        pe = pefile.PE(file_path)
        file_properties = {
            #'File Name': os.path.basename(file_path),
            'File Size': os.path.getsize(file_path),
            'Compile Time': pe.FILE_HEADER.TimeDateStamp,
            'Machine Type': hex(pe.FILE_HEADER.Machine),
            'Number of Sections': pe.FILE_HEADER.NumberOfSections,
            'API Calls': [],
            'Section Information': [],
            'Entropy': [],
            'Resources': [],
            'Certificate Information': {},
            'Hash': calculate_file_hash(file_path),
            'Packed': is_packed(pe),
            'IAT Entries': analyze_iat(pe),
            'Encrypted Section': contains_encrypted_section(pe),
            'API Calls Frequency': analyze_api_frequency(pe),
            'Suspicious Keywords Detected': None,
            'Detected Keywords': None,
            'Exported Functions': [exp.name.decode('utf-8') for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols] if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') else None,
            'Malicious': is_malware_folder
        }

        sections = [
            {
                'Name': section.Name.decode('utf-8').rstrip('\x00'),
                'Virtual Size': section.Misc_VirtualSize,
                'Real Size': section.SizeOfRawData,
                'Virtual Address': hex(section.VirtualAddress),
                'Entropy': calculate_entropy(section.get_data())
            }
            for section in pe.sections
        ]
        file_properties['Section Information'] = sections

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            file_properties['API Calls'] = [func.name.decode('utf-8') for entry in pe.DIRECTORY_ENTRY_IMPORT for func in entry.imports]

        suspicious_strings = detect_suspicious_strings(pe)
        file_properties['Suspicious Keywords Detected'] = 'Detected' if suspicious_strings else 'Not Detected'
        file_properties['Detected Keywords'] = ', '.join(suspicious_strings) if suspicious_strings else None

        resources = []
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'data'):
                            entry_data = resource_id.data.struct
                            resources.append({
                                'Type': resource_type.name,
                                'Name': resource_id.name,
                                'Language': resource_id.id,
                                'Offset': entry_data.OffsetToData,
                                'Size': entry_data.Size
                            })

        file_properties['Resources'] = resources

        if hasattr(pe, 'DIRECTORY_ENTRY_SECURITY') and pe.DIRECTORY_ENTRY_SECURITY:
            file_properties['Certificate Information'] = {
                'Type': pe.DIRECTORY_ENTRY_SECURITY.struct.CertType,
                'Name': pe.DIRECTORY_ENTRY_SECURITY.name
            }

        df = pd.DataFrame([file_properties])
        
        df.to_csv('pe_info.csv', mode='a', header=not os.path.exists('pe_info.csv'), index=False)

        logging.info(f"PE information successfully extracted: {file_path}")

    except Exception as e:
        logging.error(f"An error occurred while extracting PE information: {e}")

def process_file(args):
    file_path, is_malware_folder = args
    analyze_pe(file_path, is_malware_folder)

def analyze_files(folder_path, is_malware, file_extensions=['.exe', '.dll']):
    try:
        file_paths = []
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                if any(file.lower().endswith(ext) for ext in file_extensions):
                    file_path = os.path.join(root, file)
                    file_paths.append((file_path, is_malware))

        with multiprocessing.Pool() as pool:
            pool.map(process_file, file_paths)

    except Exception as e:
        logging.error(f"An error occurred while analyzing files: {e}")
if __name__ == "__main__":
    analyze_files(folder_path_malware, is_malware=True)
    analyze_files(folder_path_normal, is_malware=False)
