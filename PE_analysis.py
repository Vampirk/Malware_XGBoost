import os
import pefile
import pandas as pd
import hashlib
import math
from collections import Counter
import logging

# 로거 설정
logging.basicConfig(filename='pe_analyzer.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# 전역 변수를 상수로 선언
HASH_ALGORITHMS = ['md5', 'sha1', 'sha256']

# 파일 조작 관련 키워드
file_manipulation_keywords = ['CreateFile', 'WriteFile', 'ReadFile', 'DeleteFile', 'MoveFile', 'CopyFile']

# 프로세스 조작 관련 키워드
process_manipulation_keywords = ['CreateProcess', 'OpenProcess', 'TerminateProcess']

# 서비스 조작 관련 키워드
service_manipulation_keywords = ['OpenService', 'CreateService', 'StartService', 'ControlService']

# 네트워크 통신 관련 키워드
socket_keywords = ['socket', 'bind', 'connect', 'send', 'recv', 'listen']
http_communication_keywords = ['HttpOpenRequest', 'HttpSendRequest', 'InternetOpen', 'InternetOpenUrl']

# 암호화 및 압축 관련 키워드
encryption_keywords = ['CryptEncrypt', 'CryptDecrypt', 'CryptHashData']
compression_keywords = ['Compress', 'Decompress', 'Zlib', 'LZ77']

# 레지스트리 조작 관련 키워드
registry_keywords = ['RegOpenKey', 'RegCreateKey', 'RegDeleteKey', 'RegQueryValue', 'RegSetValue']

# 시스템 정보 획득 관련 키워드
system_information_keywords = ['GetSystemInfo', 'GetNativeSystemInfo', 'GetComputerName', 'GetUserName', 'GetWindowsDirectory']

# 쉘코드 관련 키워드
shellcode_keywords = ['VirtualAlloc', 'VirtualProtect', 'CreateThread', 'ShellExecute', 'GetProcAddress']

# Anti-Analysis 및 방어 기법 관련 키워드
anti_analysis_keywords = ['IsDebuggerPresent', 'OutputDebugString', 'CheckRemoteDebuggerPresent', 'VirtualQuery', 'CreateThread']

# API 호출 분석 함수
def analyze_api_frequency(pe):
    try:
        api_calls = []
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                api_calls.extend(func.name.decode('utf-8') for func in entry.imports)

        return Counter(api_calls)
    except Exception as e:
        logging.error(f"An error occurred while analyzing API frequency: {e}")
        return {}

# IAT 분석 함수
def analyze_iat(pe):
    try:
        iat_entries = []
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8')
                iat_entries.extend({'DLL': dll_name, 'Function': func.name.decode('utf-8')} for func in entry.imports)

        return iat_entries
    except Exception as e:
        logging.error(f"An error occurred while analyzing IAT: {e}")
        return []

# 엔트로피 계산 함수
def calculate_entropy(data):
    entropy = 0
    if data:
        for x in range(256):
            p_x = float(data.count(x)) / len(data)
            if p_x > 0:
                entropy += - p_x * math.log(p_x, 2)
    return entropy

# 파일 해시 계산 함수
def calculate_file_hash(file_path, hash_algorithm):
    try:
        hasher = hashlib.new(hash_algorithm)
        with open(file_path, 'rb') as file:
            while chunk := file.read(8192):
                hasher.update(chunk)
        return hasher.hexdigest()
    except Exception as e:
        logging.error(f"An error occurred while calculating file hash: {e}")
        return None

def is_packed(pe):
    try:
        nop_sequence_count = 0
        suspicious_sections = 0
        high_entropy_sections = 0

        # NOP 명령어 시퀀스 확인
        for section in pe.sections:
            if b'\x90' * 10 in section.get_data():
                nop_sequence_count += 1

        # 섹션 특성 검사
        for section in pe.sections:
            characteristics = section.Characteristics

            # 섹션이 쓰기 가능하고 실행 가능인지 확인하지만, DLL의 정상적인 특성도 고려
            if characteristics & 0x60000020 == 0x60000020:
                if section.SizeOfRawData > 512:  # 작은 섹션은 종종 정상적인 DLL에서 발견됨
                    suspicious_sections += 1

            # 섹션 크기가 너무 작은지 확인하지만, 크기만으로 판단하지 않음
            if section.SizeOfRawData < 10:
                suspicious_sections += 1

        # 엔트로피 검사, DLL 파일의 경우 다양한 데이터가 포함될 수 있으므로 임계값을 조정
        for section in pe.sections:
            if calculate_entropy(section.get_data()) > 7.0:  # 엔트로피 임계값을 조정
                high_entropy_sections += 1

        # 헤더 이상 검사, DLL 파일의 특성을 고려하여 조정
        header_anomalies = pe.FILE_HEADER.SizeOfOptionalHeader != 0xE0 or \
                           pe.OPTIONAL_HEADER.DllCharacteristics & 0x40 != 0

        # 패킹 여부 판단 로직 조정
        if nop_sequence_count > 2 or suspicious_sections > 2 or high_entropy_sections > 2 or header_anomalies:
            return True

        return False
    except Exception as e:
        logging.error(f"An error occurred while checking for packing: {e}")
        return False

        
# 암호화 섹션 여부 확인 함수
def contains_encrypted_section(pe):
    try:
        for section in pe.sections:
            if calculate_entropy(section.get_data()) > 7.0:
                return True
        return False
    except Exception as e:
        logging.error(f"An error occurred while checking for encrypted sections: {e}")
        return False

# 의심스러운 문자열 검출 함수
def detect_suspicious_strings(pe):
    try:
        suspicious_keywords = (
            file_manipulation_keywords +
            process_manipulation_keywords +
            service_manipulation_keywords +
            socket_keywords +
            http_communication_keywords +
            encryption_keywords +
            compression_keywords +
            registry_keywords +
            system_information_keywords +
            shellcode_keywords +
            anti_analysis_keywords
        )

        detected_strings = []
        for section in pe.sections:
            section_data = section.get_data().decode(errors='ignore')
            detected_strings.extend(keyword for keyword in suspicious_keywords if keyword.lower() in section_data.lower())

        return list(set(detected_strings))
    except Exception as e:
        logging.error(f"An error occurred while detecting suspicious strings: {e}")
        return []

# PE 파일 분석 함수
def analyze_pe(file_path, is_malware_folder):
    try:
        pe = pefile.PE(file_path)

        file_properties = {
            'File Name': os.path.basename(file_path),
            'File Size': os.path.getsize(file_path),
            'Compile Time': pe.FILE_HEADER.TimeDateStamp,
            'Machine Type': hex(pe.FILE_HEADER.Machine),
            'Number of Sections': pe.FILE_HEADER.NumberOfSections,
            'API Calls': [],
            'Section Information': [],
            'Entropy': [],
            'Resources': [],
            'Certificate Information': {},
            'Hash': {algorithm: calculate_file_hash(file_path, algorithm) for algorithm in HASH_ALGORITHMS},
            'Packed': is_packed(pe),
            'IAT Entries': analyze_iat(pe),
            'Encrypted Section': contains_encrypted_section(pe),
            'API Calls Frequency': analyze_api_frequency(pe),
            'Suspicious Keywords Detected': None,
            'Detected Keywords': None,
            'Exported Functions': [exp.name.decode('utf-8') for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols] if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') else None,
            'Malicious': is_malware_folder
        }

        sections = [
            {
                'Name': section.Name.decode('utf-8').rstrip('\x00'),
                'Virtual Size': section.Misc_VirtualSize,
                'Real Size': section.SizeOfRawData,
                'Virtual Address': hex(section.VirtualAddress),
                'Entropy': calculate_entropy(section.get_data())
            }
            for section in pe.sections
        ]
        file_properties['Section Information'] = sections

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            file_properties['API Calls'] = [func.name.decode('utf-8') for entry in pe.DIRECTORY_ENTRY_IMPORT for func in entry.imports]

        suspicious_strings = detect_suspicious_strings(pe)
        file_properties['Suspicious Keywords Detected'] = 'Detected' if suspicious_strings else 'Not Detected'
        file_properties['Detected Keywords'] = ', '.join(suspicious_strings) if suspicious_strings else None

        resources = []
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'data'):
                            entry_data = resource_id.data.struct
                            resources.append({
                                'Type': resource_type.name,
                                'Name': resource_id.name,
                                'Language': resource_id.id,
                                'Offset': entry_data.OffsetToData,
                                'Size': entry_data.Size
                            })

        file_properties['Resources'] = resources

        if hasattr(pe, 'DIRECTORY_ENTRY_SECURITY') and pe.DIRECTORY_ENTRY_SECURITY:
            file_properties['Certificate Information'] = {
                'Type': pe.DIRECTORY_ENTRY_SECURITY.struct.CertType,
                'Name': pe.DIRECTORY_ENTRY_SECURITY.name
            }

        df = pd.DataFrame([file_properties])
        df.to_csv('pe_info.csv', mode='a', header=not os.path.exists('pe_info.csv'), index=False)

        logging.info(f"PE information successfully extracted: {file_path}")

    except Exception as e:
        logging.error(f"An error occurred while extracting PE information: {e}")

# DLL 폴더 분석 함수
def analyze_dll_folder(folder_path, is_malware):
    try:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                if file.lower().endswith('.dll'):
                    file_path = os.path.join(root, file)
                    analyze_pe(file_path, is_malware_folder=is_malware)
    except Exception as e:
        logging.error(f"An error occurred while analyzing DLL folder: {e}")

# 폴더 분석 함수
def analyze_folder(folder_path, is_malware):
    try:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                if file.lower().endswith('.exe'):
                    file_path = os.path.join(root, file)
                    analyze_pe(file_path, is_malware_folder=is_malware)
    except Exception as e:
        logging.error(f"An error occurred while analyzing folder: {e}")

if __name__ == "__main__":
    folder_path_malware = '/home/user/Desktop/Malware/file/malicious_folder'
    analyze_folder(folder_path_malware, is_malware=True)
    analyze_dll_folder(folder_path_malware, is_malware=True)
    folder_path_normal = '/home/user/Desktop/Malware/file/normal_folder'
    analyze_folder(folder_path_normal, is_malware=False)
    analyze_dll_folder(folder_path_normal, is_malware=False)
