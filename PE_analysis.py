import os
import pefile
import pandas as pd
import hashlib
import math

# hash_algorithms 전역 변수로 선언
hash_algorithms = ['md5', 'sha1', 'sha256']

# API 호출 분석 함수
def analyze_api_frequency(pe):
    api_calls = []
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            api_calls.extend([func.name.decode('utf-8') for func in entry.imports])

    api_calls_frequency = {}
    for api_call in api_calls:
        if api_call in api_calls_frequency:
            api_calls_frequency[api_call] += 1
        else:
            api_calls_frequency[api_call] = 1

    return api_calls_frequency

# IAT 분석 함수
def analyze_iat(pe):
    iat_entries = []
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode('utf-8')
            for func in entry.imports:
                iat_entries.append({'DLL': dll_name, 'Function': func.name.decode('utf-8')})

    return iat_entries

# 엔트로피 계산 함수
def calculate_entropy(data):
    entropy = 0
    if data:
        for x in range(256):
            p_x = float(data.count(x)) / len(data)
            if p_x > 0:
                entropy += - p_x * math.log(p_x, 2)
    return entropy

# 파일 해시 계산 함수
def calculate_file_hash(file_path, hash_algorithm):
    hasher = hashlib.new(hash_algorithm)
    with open(file_path, 'rb') as file:
        while chunk := file.read(8192):
            hasher.update(chunk)
    return hasher.hexdigest()

# 패킹 여부 확인 함수
def is_packed(pe):
    if not pe.sections or not pe.OPTIONAL_HEADER.AddressOfEntryPoint:
        return True

    entry_point_section = None
    max_section_entropy = 0
    for section in pe.sections:
        if section.VirtualAddress <= pe.OPTIONAL_HEADER.AddressOfEntryPoint < section.VirtualAddress + section.Misc_VirtualSize:
            entry_point_section = section
            break

    if not entry_point_section or not entry_point_section.IMAGE_SCN_MEM_EXECUTE:
        return True

    if entry_point_section.IMAGE_SCN_MEM_WRITE:
        return True

    executable_sections = [section for section in pe.sections if section.IMAGE_SCN_MEM_EXECUTE]
    if not executable_sections:
        return True

    for section in pe.sections:
        entropy = calculate_entropy(section.get_data())
        max_section_entropy = max(max_section_entropy, entropy)

    if max_section_entropy > 7.0:
        return True

    return False

# 암호화 섹션 여부 확인 함수
def contains_encrypted_section(pe):
    for section in pe.sections:
        if calculate_entropy(section.get_data()) > 7.0:
            return True
    return False

# 파일 조작 관련 키워드
file_manipulation_keywords = ['CreateFile', 'WriteFile', 'ReadFile', 'DeleteFile', 'MoveFile', 'CopyFile']

# 프로세스 조작 관련 키워드
process_manipulation_keywords = ['CreateProcess', 'OpenProcess', 'TerminateProcess']

# 서비스 조작 관련 키워드
service_manipulation_keywords = ['OpenService', 'CreateService', 'StartService', 'ControlService']

# 네트워크 통신 관련 키워드
socket_keywords = ['socket', 'bind', 'connect', 'send', 'recv', 'listen']
http_communication_keywords = ['HttpOpenRequest', 'HttpSendRequest', 'InternetOpen', 'InternetOpenUrl']

# 암호화 및 압축 관련 키워드
encryption_keywords = ['CryptEncrypt', 'CryptDecrypt', 'CryptHashData']
compression_keywords = ['Compress', 'Decompress', 'Zlib', 'LZ77']

# 레지스트리 조작 관련 키워드
registry_keywords = ['RegOpenKey', 'RegCreateKey', 'RegDeleteKey', 'RegQueryValue', 'RegSetValue']

# 시스템 정보 획득 관련 키워드
system_information_keywords = ['GetSystemInfo', 'GetNativeSystemInfo', 'GetComputerName', 'GetUserName', 'GetWindowsDirectory']

# 쉘코드 관련 키워드
shellcode_keywords = ['VirtualAlloc', 'VirtualProtect', 'CreateThread', 'ShellExecute', 'GetProcAddress']

# Anti-Analysis 및 방어 기법 관련 키워드
anti_analysis_keywords = ['IsDebuggerPresent', 'OutputDebugString', 'CheckRemoteDebuggerPresent', 'VirtualQuery', 'CreateThread']

# 위 키워드들을 통합하여 사용할 수 있는 키워드 리스트
all_keywords = (
    file_manipulation_keywords +
    process_manipulation_keywords +
    service_manipulation_keywords +
    socket_keywords +
    http_communication_keywords +
    encryption_keywords +
    compression_keywords +
    registry_keywords +
    system_information_keywords +
    shellcode_keywords +
    anti_analysis_keywords
)

# 의심스러운 문자열 검출 함수
def detect_suspicious_strings(pe):
    suspicious_keywords = all_keywords

    detected_strings = []

    for section in pe.sections:
        section_data = section.get_data().decode(errors='ignore')
        for keyword in suspicious_keywords:
            if keyword.lower() in section_data.lower():
                detected_strings.append(keyword)

    return detected_strings

# PE 파일 분석 함수
def analyze_pe(file_path, is_malware_folder):
    try:
        pe = pefile.PE(file_path)

        file_properties = {
            'File Name': file_path, # 파일 경로와 이름
            'File Size': os.path.getsize(file_path), # 파일 크기
            'Compile Time': pe.FILE_HEADER.TimeDateStamp, # 컴파일 시간
            'Machine Type': hex(pe.FILE_HEADER.Machine), # 기계 유형
            'Number of Sections': pe.FILE_HEADER.NumberOfSections, # 섹션의 수
            'API Calls': [], # 사용된 API 호출 목록
            'Section Information': [], # 섹션 정보 목록
            'Entropy': [], # 엔트로피 값 목록
            'Resources': [], # 리소스 정보 목록
            'Certificate Information': {}, # 인증서 정보
            'Hash': {}, # 여러 해시 알고리즘을 사용한 파일 해시 값
            'Packed': is_packed(pe), # 패킹 여부
            'IAT Entries': analyze_iat(pe),  # IAT 분석 결과 추가
            'Encrypted Section': contains_encrypted_section(pe), # 암호화된 섹션 여
            'API Calls Frequency': analyze_api_frequency(pe), # API 호출 빈도 분석 결과
            'Suspicious Keywords Detected': None, # 의심스러운 키워드 검출 여부
            'Detected Keywords': None, # 검출된 의심스러운 키워드 목록
            'Exported Functions': None, # 내보내진 함수 목록
            'Malicious': is_malware_folder # 악성 코드 여부
        }

        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') and pe.DIRECTORY_ENTRY_EXPORT:
            export_symbols = [exp.name.decode('utf-8') for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols]
            file_properties['Exported Functions'] = export_symbols

        sections = []
        for section in pe.sections:
            section_info = {
                'Name': section.Name.decode('utf-8').rstrip('\x00'),
                'Virtual Size': section.Misc_VirtualSize,
                'Real Size': section.SizeOfRawData,
                'Virtual Address': hex(section.VirtualAddress),
                'Entropy': calculate_entropy(section.get_data())
            }
            sections.append(section_info)

        file_properties['Section Information'] = sections

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') and pe.DIRECTORY_ENTRY_IMPORT:
            imported_functions = []
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                imported_functions.extend([func.name.decode('utf-8') for func in entry.imports])
            file_properties['API Calls'] = imported_functions

        # 추가: 의심스러운 문자열 검출
        suspicious_strings = detect_suspicious_strings(pe)
        if suspicious_strings:
            file_properties['Suspicious Keywords Detected'] = 'Detected'
            file_properties['Detected Keywords'] = ', '.join(suspicious_strings)  # 검출된 키워드 기록
            print(f"Suspicious Keywords Detected: {suspicious_strings}")
        else:
            file_properties['Suspicious Keywords Detected'] = 'Not Detected'
            file_properties['Detected Keywords'] = None  # 검출된 키워드 없음

        resources = []
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'data'):
                            entry_data = resource_id.data.struct
                            resource_info = {
                                'Type': resource_type.name,
                                'Name': resource_id.name,
                                'Language': resource_id.id,
                                'Offset': entry_data.OffsetToData,
                                'Size': entry_data.Size
                            }
                            resources.append(resource_info)

        file_properties['Resources'] = resources

        if hasattr(pe, 'DIRECTORY_ENTRY_SECURITY') and pe.DIRECTORY_ENTRY_SECURITY:
            cert_info = {
                'Type': pe.DIRECTORY_ENTRY_SECURITY.struct.CertType,
                'Name': pe.DIRECTORY_ENTRY_SECURITY.name
            }
            file_properties['Certificate Information'] = cert_info

        for algorithm in hash_algorithms:
            file_properties['Hash'][algorithm] = calculate_file_hash(file_path, algorithm)

        # API 함수 빈도 분석 함수 호출
        api_calls_frequency = analyze_api_frequency(pe)

        # 기존 CSV에 API 빈도 정보 추가
        df_api_frequency = pd.DataFrame([{'File Name': file_path, 'API Calls Frequency': api_calls_frequency}])

        df = pd.DataFrame([file_properties])
        df.to_csv('pe_info.csv', mode='a', header=not os.path.exists('pe_info.csv'), index=False)

        print(f"PE information successfully extracted: {file_path}")

    except Exception as e:
        print(f"An error occurred while extracting PE information: {e}")

# DLL 폴더 분석 함수
def analyze_dll_folder(folder_path, is_malware):
    try:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                if file.lower().endswith('.dll'):
                    file_path = os.path.join(root, file)
                    analyze_pe(file_path, is_malware_folder=is_malware)
    except Exception as e:
        print(f"An error occurred while analyzing DLL folder: {e}")

# 폴더 분석 함수
def analyze_folder(folder_path, is_malware):
    try:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                if file.lower().endswith('.exe'):
                    file_path = os.path.join(root, file)
                    analyze_pe(file_path, is_malware_folder=is_malware)
    except Exception as e:
        print(f"An error occurred while analyzing folder: {e}")

if __name__ == "__main__":
    folder_path_malware = '/home/user/Desktop/Malware/file/malicious_folder'
    analyze_folder(folder_path_malware, is_malware=True)
    analyze_dll_folder(folder_path_malware, is_malware=True)
    folder_path_normal = '/home/user/Desktop/Malware/file/normal_folder'
    analyze_folder(folder_path_normal, is_malware=False)
    analyze_dll_folder(folder_path_normal, is_malware=False)
